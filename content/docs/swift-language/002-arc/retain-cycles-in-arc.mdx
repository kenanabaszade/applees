---
title: "Retain Cycles in ARC"
description: "Why cycles happen and how to break them safely."
category: "Swift Language"
chapter: "002"
chapterTitle: "ARC"
order: 10
---

import { DocHeader } from "@/components/docs/DocHeader";
import { DiagramCard } from "@/components/docs/DiagramCard";
import { Callout } from "@/components/docs/Callout";
import { CompareBlock } from "@/components/docs/CompareBlock";
import { KeyTakeaways } from "@/components/docs/KeyTakeaways";

<DocHeader
  title="Retain Cycles in ARC"
  subtitle="A retain cycle happens when objects keep each other alive through strong references—so ARC can’t reduce any reference count to zero."
  chapter="002"
  readingTime="~6 min"
  progress={0.22}
/>

<Callout kind="note" title="Why this matters">
  Retain cycles are rarely “ARC bugs.” They’re almost always unclear ownership
  expressed as a strong loop in your reference graph.
</Callout>

```swift filename=RetainCycle.swift linenos
final class ProfileViewController: UIViewController {
    var onDismiss: (() -> Void)?

    override func viewDidLoad() {
        super.viewDidLoad()
        onDismiss = { self.dismiss(animated: true) }
    }
}
```

```swift filename=RetainCycle.swift linenos
final class ProfileViewController: UIViewController {
    var onDismiss: (() -> Void)?

    override func viewDidLoad() {
        super.viewDidLoad()
        onDismiss = { [weak self] in
            guard let self else { return }
            self.dismiss(animated: true)
        }
    }
}
```

<KeyTakeaways
  items={[
    "A retain cycle is a strong-reference loop in the object graph.",
    "Stored closures commonly create cycles via strong self captures.",
    "Break any one strong edge (often with [weak self]) to restore deallocation.",
  ]}
  mentalModel="If there’s a closed loop of strong edges, ARC can’t reach a zero reference count inside that loop."
/>


