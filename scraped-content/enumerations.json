{
  "title": "Enumerations",
  "sections": [
    {
      "heading": "Enumeration Syntax",
      "level": 2,
      "content": "You introduce enumerations with the enum keyword and place their entire definition within a pair of braces:\n\nHere’s an example for the four main points of a compass:\n\nThe values defined in an enumeration (such as north, south, east, and west) are its enumeration cases. You use the case keyword to introduce new enumeration cases.\n\nNote\n\nSwift enumeration cases don’t have an integer value set by default, unlike languages like C and Objective-C. In the CompassPoint example above, north, south, east and west don’t implicitly equal 0, 1, 2 and 3. Instead, the different enumeration cases are values in their own right, with an explicitly defined type of CompassPoint.\n\nMultiple cases can appear on a single line, separated by commas:\n\nEach enumeration definition defines a new type. Like other types in Swift, their names (such as CompassPoint and Planet) start with a capital letter. Give enumeration types singular rather than plural names, so that they read as self-evident:\n\nThe type of directionToHead is inferred when it’s initialized with one of the possible values of CompassPoint. Once directionToHead is declared as a CompassPoint, you can set it to a different CompassPoint value using a shorter dot syntax:\n\nThe type of directionToHead is already known, and so you can drop the type when setting its value. This makes for highly readable code when working with explicitly typed enumeration values.\n\n",
      "codeExamples": [
        {
          "code": "enum SomeEnumeration {\n    // enumeration definition goes here\n}",
          "language": "swift"
        },
        {
          "code": "enum CompassPoint {\n    case north\n    case south\n    case east\n    case west\n}",
          "language": "swift"
        },
        {
          "code": "enum Planet {\n    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune\n}",
          "language": "swift"
        },
        {
          "code": "var directionToHead = CompassPoint.west",
          "language": "swift"
        },
        {
          "code": "directionToHead = .east",
          "language": "swift"
        }
      ]
    },
    {
      "heading": "Matching Enumeration Values with a Switch Statement",
      "level": 2,
      "content": "You can match individual enumeration values with a switch statement:\n\nYou can read this code as:\n\n“Consider the value of directionToHead. In the case where it equals .north, print \"Lots of planets have a north\". In the case where it equals .south, print \"Watch out for penguins\".”\n\n…and so on.\n\nAs described in Control Flow, a switch statement must be exhaustive when considering an enumeration’s cases. If the case for .west is omitted, this code doesn’t compile, because it doesn’t consider the complete list of CompassPoint cases. Requiring exhaustiveness ensures that enumeration cases aren’t accidentally omitted.\n\nWhen it isn’t appropriate to provide a case for every enumeration case, you can provide a default case to cover any cases that aren’t addressed explicitly:\n\n",
      "codeExamples": [
        {
          "code": "directionToHead = .south\nswitch directionToHead {\ncase .north:\n    print(\"Lots of planets have a north\")\ncase .south:\n    print(\"Watch out for penguins\")\ncase .east:\n    print(\"Where the sun rises\")\ncase .west:\n    print(\"Where the skies are blue\")\n}\n// Prints \"Watch out for penguins\".",
          "language": "swift"
        },
        {
          "code": "let somePlanet = Planet.earth\nswitch somePlanet {\ncase .earth:\n    print(\"Mostly harmless\")\ndefault:\n    print(\"Not a safe place for humans\")\n}\n// Prints \"Mostly harmless\".",
          "language": "swift"
        }
      ]
    },
    {
      "heading": "Iterating over Enumeration Cases",
      "level": 2,
      "content": "For some enumerations, it’s useful to have a collection of all of that enumeration’s cases. You enable this by writing : CaseIterable after the enumeration’s name. Swift exposes a collection of all the cases as an allCases property of the enumeration type. Here’s an example:\n\nIn the example above, you write Beverage.allCases to access a collection that contains all of the cases of the Beverage enumeration. You can use allCases like any other collection — the collection’s elements are instances of the enumeration type, so in this case they’re Beverage values. The example above counts how many cases there are, and the example below uses a for-in loop to iterate over all the cases.\n\nThe syntax used in the examples above marks the enumeration as conforming to the CaseIterable protocol. For information about protocols, see Protocols.\n\n",
      "codeExamples": [
        {
          "code": "enum Beverage: CaseIterable {\n    case coffee, tea, juice\n}\nlet numberOfChoices = Beverage.allCases.count\nprint(\"\\(numberOfChoices) beverages available\")\n// Prints \"3 beverages available\".",
          "language": "swift"
        },
        {
          "code": "for beverage in Beverage.allCases {\n    print(beverage)\n}\n// coffee\n// tea\n// juice",
          "language": "swift"
        }
      ]
    },
    {
      "heading": "Associated Values",
      "level": 2,
      "content": "The examples in the previous section show how the cases of an enumeration are a defined (and typed) value in their own right. You can set a constant or variable to Planet.earth, and check for this value later. However, it’s sometimes useful to be able to store values of other types alongside these case values. This additional information is called an associated value, and it varies each time you use that case as a value in your code.\n\nYou can define Swift enumerations to store associated values of any given type, and the value types can be different for each case of the enumeration if needed. Enumerations similar to these are known as discriminated unions, tagged unions, or variants in other programming languages.\n\nFor example, suppose an inventory tracking system needs to track products by two different types of barcode. Some products are labeled with 1D barcodes in UPC format, which uses the numbers 0 to 9. Each barcode has a number system digit, followed by five manufacturer code digits and five product code digits. These are followed by a check digit to verify that the code has been scanned correctly:\n\nOther products are labeled with 2D barcodes in QR code format, which can use any ISO 8859-1 character and can encode a string up to 2,953 characters long:\n\nIt’s convenient for an inventory tracking system to store UPC barcodes as a tuple of four integers, and QR code barcodes as a string of any length.\n\nIn Swift, an enumeration to define product barcodes of either type might look like this:\n\nThis can be read as:\n\n“Define an enumeration type called Barcode, which can take either a value of upc with an associated value of type (Int, Int, Int, Int), or a value of qrCode with an associated value of type String.”\n\nThis definition doesn’t provide any actual Int or String values — it just defines the type of associated values that Barcode constants and variables can store when they’re equal to Barcode.upc or Barcode.qrCode.\n\nYou can then create new barcodes using either type:\n\nThis example creates a new variable called productBarcode and assigns it a value of Barcode.upc with an associated tuple value of (8, 85909, 51226, 3).\n\nYou can assign the same product a different type of barcode:\n\nAt this point, the original Barcode.upc and its integer values are replaced by the new Barcode.qrCode and its string value. Constants and variables of type Barcode can store either a .upc or a .qrCode (together with their associated values), but they can store only one of them at any given time.\n\nYou can check the different barcode types using a switch statement, similar to the example in Matching Enumeration Values with a Switch Statement. This time, however, the associated values are extracted as part of the switch statement. You extract each associated value as a constant (with the let prefix) or a variable (with the var prefix) for use within the switch case’s body:\n\nIf all of the associated values for an enumeration case are extracted as constants, or if all are extracted as variables, you can place a single let or var annotation before the case name, for brevity:\n\nWhen you’re matching just one case of an enumeration — for example, to extract its associated value — you can use an if-case statement instead of writing a full switch statement. Here’s what it looks like:\n\nJust like in the switch statement earlier, the productBarcode variable is matched against the pattern .qrCode(let productCode) here. And as in the switch case, writing let extracts the associated value as a constant. For more information about if-case statements, see Patterns.\n\n",
      "codeExamples": [
        {
          "code": "enum Barcode {\n    case upc(Int, Int, Int, Int)\n    case qrCode(String)\n}",
          "language": "swift"
        },
        {
          "code": "var productBarcode = Barcode.upc(8, 85909, 51226, 3)",
          "language": "swift"
        },
        {
          "code": "productBarcode = .qrCode(\"ABCDEFGHIJKLMNOP\")",
          "language": "swift"
        },
        {
          "code": "switch productBarcode {\ncase .upc(let numberSystem, let manufacturer, let product, let check):\n    print(\"UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check).\")\ncase .qrCode(let productCode):\n    print(\"QR code: \\(productCode).\")\n}\n// Prints \"QR code: ABCDEFGHIJKLMNOP.\"",
          "language": "swift"
        },
        {
          "code": "switch productBarcode {\ncase let .upc(numberSystem, manufacturer, product, check):\n    print(\"UPC : \\(numberSystem), \\(manufacturer), \\(product), \\(check).\")\ncase let .qrCode(productCode):\n    print(\"QR code: \\(productCode).\")\n}\n// Prints \"QR code: ABCDEFGHIJKLMNOP.\"",
          "language": "swift"
        },
        {
          "code": "if case .qrCode(let productCode) = productBarcode {\n    print(\"QR code: \\(productCode).\")\n}",
          "language": "swift"
        }
      ]
    },
    {
      "heading": "Raw Values",
      "level": 2,
      "content": "The barcode example in Associated Values shows how cases of an enumeration can declare that they store associated values of different types. As an alternative to associated values, enumeration cases can come prepopulated with default values (called raw values), which are all of the same type.\n\nHere’s an example that stores raw ASCII values alongside named enumeration cases:\n\nHere, the raw values for an enumeration called ASCIIControlCharacter are defined to be of type Character, and are set to some of the more common ASCII control characters. Character values are described in Strings and Characters.\n\nRaw values can be strings, characters, or any of the integer or floating-point number types. Each raw value must be unique within its enumeration declaration.\n\nAlthough you can use both raw values and associated values to give an enumeration an additional value, it’s important to understand the difference between them. You pick the raw value for an enumeration case when you define that enumeration case in your code, such as the three ASCII codes above. The raw value for a particular enumeration case is always the same. In contrast, you pick associated values when you create a new constant or variable using one of the enumeration’s cases, and you can pick a different value each time you do so.\n\n",
      "codeExamples": [
        {
          "code": "enum ASCIIControlCharacter: Character {\n    case tab = \"\\t\"\n    case lineFeed = \"\\n\"\n    case carriageReturn = \"\\r\"\n}",
          "language": "swift"
        }
      ]
    },
    {
      "heading": "Implicitly Assigned Raw Values",
      "level": 3,
      "content": "When you’re working with enumerations that store integer or string raw values, you don’t have to explicitly assign a raw value for each case. When you don’t, Swift automatically assigns the values for you.\n\nFor example, when integers are used for raw values, the implicit value for each case is one more than the previous case. If the first case doesn’t have a value set, its value is 0.\n\nThe enumeration below is a refinement of the earlier Planet enumeration, with integer raw values to represent each planet’s order from the sun:\n\nIn the example above, Planet.mercury has an explicit raw value of 1, Planet.venus has an implicit raw value of 2, and so on.\n\nWhen strings are used for raw values, the implicit value for each case is the text of that case’s name.\n\nThe enumeration below is a refinement of the earlier CompassPoint enumeration, with string raw values to represent each direction’s name:\n\nIn the example above, CompassPoint.south has an implicit raw value of \"south\", and so on.\n\nYou access the raw value of an enumeration case with its rawValue property:\n\n",
      "codeExamples": [
        {
          "code": "enum Planet: Int {\n    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune\n}",
          "language": "swift"
        },
        {
          "code": "enum CompassPoint: String {\n    case north, south, east, west\n}",
          "language": "swift"
        },
        {
          "code": "let earthsOrder = Planet.earth.rawValue\n// earthsOrder is 3\n\n\nlet sunsetDirection = CompassPoint.west.rawValue\n// sunsetDirection is \"west\"",
          "language": "swift"
        }
      ]
    },
    {
      "heading": "Initializing from a Raw Value",
      "level": 3,
      "content": "If you define an enumeration with a raw-value type, the enumeration automatically receives an initializer that takes a value of the raw value’s type (as a parameter called rawValue) and returns either an enumeration case or nil. You can use this initializer to try to create a new instance of the enumeration.\n\nThis example identifies Uranus from its raw value of 7:\n\nNot all possible Int values will find a matching planet, however. Because of this, the raw value initializer always returns an optional enumeration case. In the example above, possiblePlanet is of type Planet?, or “optional Planet.”\n\nNote\n\nThe raw value initializer is a failable initializer, because not every raw value will return an enumeration case. For more information, see Failable Initializers.\n\nIf you try to find a planet with a position of 11, the optional Planet value returned by the raw value initializer will be nil:\n\nThis example uses optional binding to try to access a planet with a raw value of 11. The statement if let somePlanet = Planet(rawValue: 11) creates an optional Planet, and sets somePlanet to the value of that optional Planet if it can be retrieved. In this case, it isn’t possible to retrieve a planet with a position of 11, and so the else branch is executed instead.\n\n",
      "codeExamples": [
        {
          "code": "let possiblePlanet = Planet(rawValue: 7)\n// possiblePlanet is of type Planet? and equals Planet.uranus",
          "language": "swift"
        },
        {
          "code": "let positionToFind = 11\nif let somePlanet = Planet(rawValue: positionToFind) {\n    switch somePlanet {\n    case .earth:\n        print(\"Mostly harmless\")\n    default:\n        print(\"Not a safe place for humans\")\n    }\n} else {\n    print(\"There isn't a planet at position \\(positionToFind)\")\n}\n// Prints \"There isn't a planet at position 11\".",
          "language": "swift"
        }
      ]
    },
    {
      "heading": "Recursive Enumerations",
      "level": 2,
      "content": "A recursive enumeration is an enumeration that has another instance of the enumeration as the associated value for one or more of the enumeration cases. You indicate that an enumeration case is recursive by writing indirect before it, which tells the compiler to insert the necessary layer of indirection.\n\nFor example, here is an enumeration that stores simple arithmetic expressions:\n\nYou can also write indirect before the beginning of the enumeration to enable indirection for all of the enumeration’s cases that have an associated value:\n\nThis enumeration can store three kinds of arithmetic expressions: a plain number, the addition of two expressions, and the multiplication of two expressions. The addition and multiplication cases have associated values that are also arithmetic expressions — these associated values make it possible to nest expressions. For example, the expression (5 + 4) * 2 has a number on the right-hand side of the multiplication and another expression on the left-hand side of the multiplication. Because the data is nested, the enumeration used to store the data also needs to support nesting — this means the enumeration needs to be recursive. The code below shows the ArithmeticExpression recursive enumeration being created for (5 + 4) * 2:\n\nA recursive function is a straightforward way to work with data that has a recursive structure. For example, here’s a function that evaluates an arithmetic expression:\n\nThis function evaluates a plain number by simply returning the associated value. It evaluates an addition or multiplication by evaluating the expression on the left-hand side, evaluating the expression on the right-hand side, and then adding them or multiplying them.\n\n",
      "codeExamples": [
        {
          "code": "enum ArithmeticExpression {\n    case number(Int)\n    indirect case addition(ArithmeticExpression, ArithmeticExpression)\n    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)\n}",
          "language": "swift"
        },
        {
          "code": "indirect enum ArithmeticExpression {\n    case number(Int)\n    case addition(ArithmeticExpression, ArithmeticExpression)\n    case multiplication(ArithmeticExpression, ArithmeticExpression)\n}",
          "language": "swift"
        },
        {
          "code": "let five = ArithmeticExpression.number(5)\nlet four = ArithmeticExpression.number(4)\nlet sum = ArithmeticExpression.addition(five, four)\nlet product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))",
          "language": "swift"
        },
        {
          "code": "func evaluate(_ expression: ArithmeticExpression) -> Int {\n    switch expression {\n    case let .number(value):\n        return value\n    case let .addition(left, right):\n        return evaluate(left) + evaluate(right)\n    case let .multiplication(left, right):\n        return evaluate(left) * evaluate(right)\n    }\n}\n\n\nprint(evaluate(product))\n// Prints \"18\".",
          "language": "swift"
        }
      ]
    }
  ]
}